#!/usr/bin/env bash

# unlike SIM projects, each compiler project has a name of its own
PROGRAM=NFAMATCH

# this shifts off ${1:-.} to COMPLOC
source "${COMPGRADING}/comp-lib.sh"

set -e

test_missing_datafile "${comploc}/${PROGRAM}" MISSINGDATAFILE /dev/null 

test_empty_datafile "${comploc}/${PROGRAM}" EMPTYDATAFILE /dev/null 

cmp_match()
{
	local nfaid="${1}"
	local tally="${2}"
	local tok="${3}"
	local gm="${4}"
	local tm="${5}"
	if test -z "${tm}" ; then
		touch "${tally}.${RANDOM}.mbad"
		grader_msg <<EOT
error: No output found for token '${tok}' matched by '${nfaid}'!
error: (this may due to *previous* match results missing in the OUTPUT!)
EOT
		grader_keystroke
	fi
	if test "${gm}" = "${tm}" ; then
		touch "${tally}.${RANDOM}.mgood"
		grader_echo "Token '${tok}' match result for '${nfaid}' is GOOD :)"
	else 
		touch "${tally}.${RANDOM}.mbad"
		grader_msg <<EOT
error: Token '${tok}' match result for '${nfaid}' should be ${gm}, found ${tm}.
EOT
		# strange, whacky behaviour in both bsd and linux terminals when we 
		# call this too much, which admittedly occurs only when I'm stress 
		# testing...
		#grader_keystroke
	fi
	return 0
}

test_nfamatch_result()
{
	local nfafile="${graderloc}/${1}"
	local nfaid="`basename "${nfafile}"`"
	nfaid="${nfaid%.nfa}"
	local tt="${nfafile%.nfa}.tt"
	local tokenf="${nfafile%.nfa}.tok"
	# tokenf may not exist
	local tokens=`cat "${tokenf}" 2>/dev/null| tr '\n' ' '`
	local matches="${nfafile%.nfa}.m"
	local tally="${2}/${nfaid}"  # where to keep grading tallies
	local testtt="./_${nfaid}.tt"
	local testm="./_${nfaid}.m"
	local testcmp="./_${nfaid}.cmptt"

	# we need matches file only if there are tokens found for nfa
	for gf in nfafile tt `test -n "${tokens}" && echo matches` ; do 
		if ! test -r "${!gf}" -a -s "${!gf}" ; then
			grader_msg <<EOT
error:  '${!gf}' is empty or cannot be accessed, fix your environment!
EOT
			exit 1
		fi
	done

	# will display error message on non-zero exit status
	test_run "${comploc}/${PROGRAM}" "${nfafile}" "${testtt}" ${tokens:+""} ${tokens} | "${COMPGRADING}/output-pipe" >${testm}

	if ! "${COMPGRADING}/cmptt" "${tt}" "${testtt}" >/dev/null 2>"${testcmp}" ; then
		touch "${tally}.ttbad"
		grader_msg <<EOT
Optimized transition table stored in '${testtt}' (generated by '${1}') is
incorrect, comparison results against 
  ${tt}
are store in '${testcmp}', examine this text file for failure details.
EOT
		grader_keystroke
	else
		touch "${tally}.ttgood"
		grader_echo "Optimized transition table stored in '${testtt}' is GOOD :)"
	fi

	# bail now if token matching not done for this nfa
	test -z "${tokens}" && return 

	cmp_match ${nfaid} "${tally}" "" `head -n 1 <"${matches}"` `head -n 1 <"${testm}"`
	paste "${tokenf}" <(sed -e 1d "${matches}") <(sed -e 1d "${testm}") | while read tok gm tm ; do 
		cmp_match ${nfaid} "${tally}" "${tok}" "${gm}" "${tm}"
	done
	return 0
}



# make tally dirs for rubric line items, test the appropriate nfas
deadtallydir=`grader_mktemp -d deadtally`
for nfa in `( cd "${graderloc}" && ls -1 dead-*.nfa )` ; do 
	test_nfamatch_result "${nfa}" "${deadtallydir}"
done


unreachtallydir=`grader_mktemp -d unreachtally`
for nfa in `( cd "${graderloc}" && ls -1 unreach-*.nfa )` ; do 
	test_nfamatch_result "${nfa}" "${unreachtallydir}"
done


matchtallydir=`grader_mktemp -d matchtally`
for nfa in `( cd "${graderloc}" && ls -1 match-*.nfa )` ; do 
	test_nfamatch_result "${nfa}" "${matchtallydir}"
done


show_tallies()
{
	local tallydir="${1}"
	shift
	local descr="${@}" 
	# tallies
	local totaltt=`ls -1 "${tallydir}/"*.tt[gb]* 2>/dev/null|wc -l | tr -d '[:space:]'`
	local goodtt=`ls -1 "${tallydir}/"*.ttgood 2>/dev/null|wc -l | tr -d '[:space:]'`
	local totalm=`ls -1 "${tallydir}/"*.m[gb]* 2>/dev/null|wc -l | tr -d '[:space:]'`
	local goodm=`ls -1 "${tallydir}/"*.mgood 2>/dev/null|wc -l | tr -d '[:space:]'`

#   alamode bc incompatible, need to use simple awk
#	pcttt=0
#	test $totaltt -gt 0 && pcttt=`bc -e "scale=5 ; ( ${goodtt} / ${totaltt} ) * 100;" -e quit`
#	pctm=0
#	test $totalm -gt 0 && pctm=`bc -e "scale=5 ; ( ${goodm} / ${totalm} ) * 100;" -e quit`
#
	if test ${totalm} -gt 0 ; then
		grader_msg << EOT 
** ${descr} **
Transition Table results ${goodtt} out of ${totaltt} correct.
Match results ${goodm} out of ${totalm} correct.
EOT
	else
		grader_msg << EOT 
** ${descr} **
Transition Table results ${goodtt} out of ${totaltt} correct.
EOT
	fi
}

show_tallies ${deadtallydir} "DFAs Pruned of Dead States"
show_tallies ${unreachtallydir} "DFAs Pruned of Unreachable States"
show_tallies ${matchtallydir} "Optimized DFAs and Token Matching"


# always show cwd at the end, so grader is sure the correct results
# are recorded for the correct submission (the upload id is in the path)
pwd

